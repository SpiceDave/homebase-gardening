package com.mozaic{	import flash.system.JPEGLoaderContext;	import flash.utils.ByteArray;	import flash.filesystem.*;	import flash.display.*;	import flash.events.Event;	import flash.net.URLRequest;	import com.adobe.images.JPGEncoder;	import com.adobe.images.PNGEncoder;	import flash.geom.Point;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.geom.ColorTransform;	import flash.filters.ColorMatrixFilter;	import flash.filters.GlowFilter;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.Font;	import flash.text.AntiAliasType;	import flash.events.IOErrorEvent;		public class mozaic	{		/*stores the csv data as an object array */		var submission:Array = new Array();		var TILE_NO:int;//qty		var TILE_SIZE:int;//pixels		var MOSAIC_WIDTH:int;//pixels		var ROW_WIDTH:int;//width of mosaic divided by width of cells		const USER_IMG_SIZE:int = 172;//square		var _html:String;		var _htmlFile:String;		var _targetImgDir:String;		var _sourceImgDir:String;		var _dir:String;				public function mozaic(noOfTiles:int, tileSize:int, mosaicWidth:int, dir:String)		{			// constructor code			trace('Processor loaded...');			//original var thisMosaic:Array = new Array(1998, 15, 810);//number of tiles, tile size, mosaic width in px.						TILE_NO = noOfTiles;			TILE_SIZE = tileSize;			MOSAIC_WIDTH = mosaicWidth;			ROW_WIDTH = MOSAIC_WIDTH / TILE_SIZE;			_dir = dir;		}		/* Main function */		public function process(csvFile:String, sourceImgDir:String, targetImgDir:String, mainImageFile:String, htmlFile:String ):void		{			_htmlFile = htmlFile;			_sourceImgDir = sourceImgDir;			_targetImgDir = targetImgDir;			/*upload necessary files*/			var mImage:File = new File(mainImageFile);			var req:URLRequest = new URLRequest(mImage.url);			var ldr:Loader = new Loader();			ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);			ldr.load(req);			var csv:File = new File(csvFile);			var fileContent:String = getFileContent(csv);			//get the submissions			submission = parseCSV(fileContent);						//trace(submission[1500].image);		}		private function completeHandler(event:Event):void 		{			  var ldr:Loader = Loader(event.target.loader);			  var b:Bitmap = Bitmap(ldr.content);			  var row:int = 1;			  var j:int = 1;			  var color:String;			  var imgCellCode:String;			  var liveCellClass:String;			  var _data:String;			  var theTime:Date = new Date();			  _html = '<div id="mosaic-inner" style="position:relative">';			  //add the colors metadata to the shuffled records			  for(var i:int = 0; i<TILE_NO; i++)			  {								  				  if((j)%(ROW_WIDTH + 1) == 0)				  {					  row++;					  j = 0;					  i--;					  _html += '<div style="clear:both"></div>';				  }				  else				  {					  color = int(b.bitmapData.getPixel((j*TILE_SIZE) - (TILE_SIZE/2), (row*TILE_SIZE)-(TILE_SIZE-2))).toString(16);//hex					  if(color.length == 5)					  {						  color = '0' + color;					  }					  submission[i].color = color;					//trace(i + ' ' + submission[i].color+ ' ' +j + ' ' + row);					if(submission[i].image != 'empty')					{					  	var imgOutArray:Array =  ('img/target/' + _dir + submission[i].image).split('.');						imgCellCode = '<img src="'+imgOutArray[0]+'_c.jpg?' + theTime.time  +'"/><div class="highlight"></div>';						liveCellClass = ' live-cell';						_data = ' data-name="'+submission[i].name + '" data-tag="'+submission[i].tag+'" data-image="'+imgOutArray[0]+'_m.jpg" data-copy="'+ submission[i].copy +'" ';									}					else					{						imgCellCode = '';						liveCellClass = '';						_data = '';					}					  _html += '<div class="mCell'+ liveCellClass +'" id="' + i + '"' + _data + ' style="background-color:#' + submission[i].color + ';">'+ imgCellCode + '</div>';				  }				  j++;			  }			  _html += '</div>';			  writeHTML(_html);			  createImages(); 		}		/* write the mosiac html code to file */		private function writeHTML(code):void{			var file:File = File.desktopDirectory.resolvePath(_htmlFile);			var stream:FileStream = new FileStream();			stream.open(file, FileMode.WRITE);			stream.writeUTFBytes(code);			stream.close();		}		/* write the small mosaic image html to file */		private function writeImage(jpg:ByteArray, tpath:String):void{			trace('Saving file: ' + tpath);			var file:File = File.desktopDirectory.resolvePath(tpath);			var stream:FileStream = new FileStream();			stream.open(file, FileMode.WRITE);			stream.writeBytes ( jpg, 0, jpg.length );			stream.close();		}		/* Gets the handle to the csv file */		private function getFileContent(_file:File):String		{			//open a fileStream to read the content of the file			var fileStream:FileStream = new FileStream();			fileStream.open(_file, FileMode.READ);			var fileContent:String = fileStream.readUTFBytes(fileStream.bytesAvailable);			fileStream.close();			return fileContent;		}		/* Parses the csv file's content that is passsed to it, and returns an array of object */		private function parseCSV(_content:String):Array		{			var csvContent:Array = new Array();			var loadedData = _content.split(/\r\n|\n|\r/);			//for each record as a mosaic tile			for (var i:int=1; i<=TILE_NO; i++){				try				{					//for tiles with data					if(i < loadedData.length)					{						var csvLine:String = loadedData[i];						var quoteStart:int = csvLine.indexOf('"');						var quoteEnd:int = csvLine.lastIndexOf('"');												var brokenString:Array = new Array();												//get the first part of the string before the quote						brokenString.push(csvLine.substring(0, quoteStart));																		//quoted section						var subStr:String = csvLine.substring(quoteStart, quoteEnd+1);												subStr = subStr.replace(/,/g, "alskdjfhg");						subStr = subStr.replace(/"/g, "");												brokenString.push(subStr);												//section after						brokenString.push(csvLine.substring(quoteEnd+1, csvLine.length));												//put back together						loadedData[i] = brokenString[0] + brokenString[1] + brokenString[2];												loadedData[i] = loadedData[i].split(",");												//now data is split we can add back the comma to the string						var story:String = loadedData[i][3];						story = story.replace(/alskdjfhg/g, ",");												//create unique imagename for defualt blank images						var imagename = loadedData[i][4];						if(imagename ==  'frameOneLogo.jpg')						{							imagename = loadedData[i][0] + '.jpg';						}												var image:String = loadedData[i][4]; 												//get entry date and convert						var date:Array = loadedData[i][10].split('/');						var month:String;												switch(date[0]){							case '03':								month = 'March';								break;							case '04':								month = 'April';								break;							case '05':								month = 'May';								break;							case '06':								month = 'June';								break;							case '07':								month = 'July';						}										var entryDate = date[1] + ' ' + month + ' 2013';										csvContent.push({'name':loadedData[i][1], 								'email':loadedData[i][2],								'image':imagename,								'copy':story,								'tag':loadedData[i][7],								'color':'empty',								'date':entryDate});					}													//else create empty record to facilitate shuffling with populated tiles					else					{						csvContent.push({'name':'empty', 										'email':'empty',										'image':'empty',										'copy':'empty',										'tag':'empty',										'color':'empty',										'date':'empty'});					}				}				catch(e:Error)				{					trace('csv error at line: ' + i);				}							}			shuffle(csvContent)			return csvContent;		}		/* create the images for the mosaic */		private function createImages():void{			 for(var i:int = 0; i<TILE_NO; i++)			 {				 var submittedImage:String = submission[i].image;				 var colorTint:String = submission[i].color;				 if(submittedImage != 'empty')				 {					 trace('image to convert: ' + submittedImage + ' with a color tint of: ' + colorTint + ' belonging to: ' + submission[i].name);					 //remove the file extension					 var imgOutArray:Array =  (_targetImgDir+'/'+ submission[i].image).split('.');				     generateImages(_sourceImgDir+'/'+ submission[i].image, imgOutArray[0], colorTint, i);					 				}			 }			 function generateImages(imgIn:String, imgOut:String, tint:String, id:int):void			 {				 				 /*upload necessary files*/				/*deal with missing files or non entered files */				var iImage:File = new File(imgIn);				var ureq:URLRequest = new URLRequest(iImage.url);								var ldr:Loader = new Loader();				ldr.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, noFileToUpload);				ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, smallImageUploadHandler);				ldr.load(ureq); 								 function noFileToUpload(evt:IOErrorEvent)				 {					 trace('Missing file: ' + iImage.url);					 var blankEncoder:JPGEncoder = new JPGEncoder(100);					 					 var blank:BitmapData = new BitmapData(250, 250, false, 0xFFFFFF);//white background					 var _blankImage:blankImage = new blankImage();				    var matrixBlank:Matrix = new Matrix();				  	matrixBlank.translate(0,0);				    blank.draw(_blankImage, matrixBlank);					var blankByteArayMain:ByteArray = blankEncoder.encode(blank);				  	writeImage(blankByteArayMain, imgIn);				 }					/* original code				var iImage:File = new File(imgIn);				var ureq:URLRequest = new URLRequest(iImage.url);				var ldr:Loader = new Loader();				ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, smallImageUploadHandler);				ldr.load(ureq); 				*/													function smallImageUploadHandler(event:Event):void 				{				  //encoder class instantiation				  var jpgEncoder:JPGEncoder = new JPGEncoder(95);				  //var pngEncoder:PNGEncoder = new PNGEncoder(); /* for png encoding alternative - file sizes seem a bit large */				  var ldr:Loader = Loader(event.target.loader);				  var bmp:Bitmap = Bitmap(ldr.content);				  var mainSubmittedImage:Bitmap = new Bitmap();//user's photo				  var backgroundImage:BitmapData = new BitmapData(430, 172, false, 0xFFFFFF);//white background				  				  //set sizes for image crop				  var imgWidth:int = bmp.width;				  var imgHeight:int = bmp.height;				  				  trace('uploading image: ' + imgIn);				  				  /********* convert the main images first ********/						   //-->landscape or square				  if(imgWidth >= imgHeight)				  {					  mainSubmittedImage = crop((imgWidth - imgHeight)/2, 0, imgHeight, imgHeight, bmp);				  }				  				  //-->portrait				  if(imgHeight >= imgWidth)				  {					  //do the crop					  mainSubmittedImage = crop(0, (imgHeight - imgWidth)/2, imgWidth, imgWidth, bmp);				  }				  				  //scale the image				  mainSubmittedImage = drawScaled(mainSubmittedImage, Number(USER_IMG_SIZE), Number(USER_IMG_SIZE));				  				  var bmdMain:Bitmap = new Bitmap(mainSubmittedImage.bitmapData);				  backgroundImage.draw(bmdMain);				  //write text to the background image				  drawString(backgroundImage, '- ' + submission[id].name,186,20, '15', '0x8a8a8a', true, 150);				  drawString(backgroundImage, submission[id].copy,186,70, '13', '0xb2b2b2', true, 238);				  drawString(backgroundImage, submission[id].date,186,146, '14', '0xb2b2b2', true, 238);				  				  //add other elements to image				  var horizontalRule:hr = new hr();				  var back2image:back2mosaic = new back2mosaic();				  var triangle:pointer = new pointer();				  				  var matrixHr:Matrix = new Matrix();				  var matrixB2I:Matrix = new Matrix();				  var matrixTri:Matrix = new Matrix();				  matrixHr.translate(186,135);				  backgroundImage.draw(horizontalRule, matrixHr);				  matrixB2I.translate(344,00);				  backgroundImage.draw(back2image, matrixB2I);				  matrixTri.translate(163,46);				  backgroundImage.draw(triangle, matrixTri);				  //process and save the image				  				  /*var pngByteArayMain:ByteArray = pngEncoder.encode(backgroundImage);				  writeImage(pngByteArayMain, imgOut + '_m.png');*/				  var jpgByteArayMain:ByteArray = jpgEncoder.encode(backgroundImage);				  writeImage(jpgByteArayMain, imgOut + '_m.jpg');				  				  				  /******** convert the small cell images ********/				  				  //convert to grayscale				  const rc:Number = 1/3, gc:Number = 1/3, bc:Number = 1/3;								  bmp.bitmapData.applyFilter(bmp.bitmapData, bmp.bitmapData.rect, new Point(), new ColorMatrixFilter([rc, gc, bc, 0, 0,rc, gc, bc, 0, 0, rc, gc, bc, 0, 0, 0, 0, 0, 1, 0]));				  bmp.bitmapData.applyFilter(bmp.bitmapData, bmp.bitmapData.rect, new Point(), setContrast(-50));				  bmp.bitmapData.applyFilter(bmp.bitmapData, bmp.bitmapData.rect, new Point(), setBrightness(50));								  				  				  				  //-->landscape or square				  if(imgWidth >= imgHeight)				  {					  bmp = crop((imgWidth - imgHeight)/2, 0, imgHeight, imgHeight, bmp);				  }				  				  //-->portrait				  if(imgHeight >= imgWidth)				  {					  //do the crop					  bmp = crop(0, (imgHeight - imgWidth)/2, imgWidth, imgWidth, bmp);				  }				  				  //scale the image				  bmp = drawScaled(bmp, Number(TILE_SIZE), Number(TILE_SIZE));				  				  //color the image				  var cTransform:ColorTransform = new ColorTransform();				  cTransform.alphaMultiplier = 2;				  var hex:Number = Number('0x' + tint);				  cTransform.redMultiplier = 1 /(255 / Number((hex & 0xFF0000) >> 16));				  cTransform.greenMultiplier = 1 /(255 /Number((hex & 0x00FF00) >> 8));				  cTransform.blueMultiplier = 1 /(255 / Number((hex & 0x0000FF)));  				  var rect:Rectangle = new Rectangle(0, 0, TILE_SIZE, TILE_SIZE);				  bmp.bitmapData.colorTransform(rect, cTransform);				  bmp.bitmapData.applyFilter(bmp.bitmapData, bmp.bitmapData.rect, new Point(), setContrast(50));				  bmp.bitmapData.applyFilter(bmp.bitmapData, bmp.bitmapData.rect, new Point(), setBrightness(25));				  bmp.bitmapData.applyFilter(bmp.bitmapData, bmp.bitmapData.rect, new Point(), setSaturation(30));									  var bm:Bitmap = new Bitmap(bmp.bitmapData);				  				  var jpgByteAray:ByteArray = jpgEncoder.encode(bm.bitmapData);				  writeImage(jpgByteAray, imgOut+ '_c.jpg');			 	}			 }		}		/*crop the bitmap */		function crop( _x:Number, _y:Number, _width:Number, _height:Number, displayObject:DisplayObject = null):Bitmap		{		   var cropArea:Rectangle = new Rectangle( 0, 0, _width, _height );		   var croppedBitmap:Bitmap = new Bitmap( new BitmapData( _width, _height ), PixelSnapping.ALWAYS, true );		   croppedBitmap.bitmapData.draw(displayObject, new Matrix(1, 0, 0, 1, -_x, -_y) , null, null, cropArea, true );		   return croppedBitmap;		}		/* rescale the image */		function drawScaled(obj:DisplayObject, thumbWidth:Number, thumbHeight:Number):Bitmap {			var m:Matrix = new Matrix();			m.scale(thumbWidth / obj.width, thumbWidth / obj.height);			var bmp:BitmapData = new BitmapData(thumbWidth, thumbHeight, false);			bmp.draw(obj, m);			return new Bitmap(bmp);		}		/* lovely function from http://bost.ocks.org/mike/shuffle/ used to shuffle the array of submissions */		private function shuffle(array):Array 		{			var m = array.length, t, i;			// While there remain elements to shuffle			while (m) {				// Pick a remaining element…				i = Math.floor(Math.random() * m--);				// And swap it with the current element.				t = array[m];				array[m] = array[i];				array[i] = t;			}			return array;		}		private function drawString(target:BitmapData,text:String,x:Number,y:Number, text_size, text_color, wordwrap, tfWidth:int):void {			var tff:TextFormat = new TextFormat();			tff.size = text_size;			tff.leading = 1.90;			tff.letterSpacing = -0.1;			var tffont = new homebaseBold;			tff.font = tffont.fontName;			var tf:TextField = new TextField();			tf.defaultTextFormat = tff;			tf.antiAliasType=AntiAliasType.ADVANCED;			tf.thickness = 50;			tf.sharpness = 200;			tf.textColor = text_color;			tf.wordWrap = wordwrap;			tf.text = text;			tf.width = tfWidth;			var bmd:BitmapData = new BitmapData(tf.width,tf.height);			bmd.draw(tf);			var mat:Matrix = new Matrix();			mat.translate(x,y);			target.draw(bmd,mat);			bmd.dispose();		}												private function setBrightness(value:Number):ColorMatrixFilter		{			value = value*(255/250);						var m:Array = new Array();    		m = m.concat([1, 0, 0, 0, value]);	// red   		 	m = m.concat([0, 1, 0, 0, value]);	// green   		 	m = m.concat([0, 0, 1, 0, value]);	// blue    		m = m.concat([0, 0, 0, 1, 0]);		// alpha    		    		return new ColorMatrixFilter(m);		}				/**		 * sets contrast value available are -100 ~ 100 @default is 0		 * @param 		value:int	contrast value		 * @return		ColorMatrixFilter		 */		private function setContrast(value:Number):ColorMatrixFilter		{			value /= 100;			var s: Number = value + 1;    		var o : Number = 128 * (1 - s);						var m:Array = new Array();			m = m.concat([s, 0, 0, 0, o]);	// red			m = m.concat([0, s, 0, 0, o]);	// green			m = m.concat([0, 0, s, 0, o]);	// blue			m = m.concat([0, 0, 0, 1, 0]);	// alpha						return new ColorMatrixFilter(m);		}				/**		 * sets saturation value available are -100 ~ 100 @default is 0		 * @param 		value:int	saturation value		 * @return		ColorMatrixFilter		 */		private function setSaturation(value:Number):ColorMatrixFilter		{			const lumaR:Number = 0.212671;    		const lumaG:Number = 0.71516;    		const lumaB:Number = 0.072169;						var v:Number = (value/100) + 1;			var i:Number = (1 - v);   		 	var r:Number = (i * lumaR);    		var g:Number = (i * lumaG);    		var b:Number = (i * lumaB);						var m:Array = new Array();			m = m.concat([(r + v), g, b, 0, 0]);	// red			m = m.concat([r, (g + v), b, 0, 0]);	// green			m = m.concat([r, g, (b + v), 0, 0]);	// blue			m = m.concat([0, 0, 0, 1, 0]);			// alpha			 			return new ColorMatrixFilter(m);		}				private function ucWords(obj:Object):Object		{			var wordsArray:Array = obj.input.split(" ");			for (var a in wordsArray){				wordsArray[a] = String(wordsArray[a]).charAt(0).toUpperCase() + String(wordsArray[a]).substr(1, String(wordsArray[a]).length);			}			return { output:wordsArray.join(" ")};		}	}}